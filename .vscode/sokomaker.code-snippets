{
  "DirectionLookup.fromName": {
    "prefix": "Soko.DIRECTION:fromName",
    "body": "Soko.DIRECTION:fromName(name)",
    "description": ""
  },
  "DirectionLookup.Down": {
    "prefix": "Soko.DIRECTION.Down",
    "body": "Soko.DIRECTION.Down",
    "description": ""
  },
  "DirectionLookup.Left": {
    "prefix": "Soko.DIRECTION.Left",
    "body": "Soko.DIRECTION.Left",
    "description": ""
  },
  "DirectionLookup.None": {
    "prefix": "Soko.DIRECTION.None",
    "body": "Soko.DIRECTION.None",
    "description": ""
  },
  "DirectionLookup.Right": {
    "prefix": "Soko.DIRECTION.Right",
    "body": "Soko.DIRECTION.Right",
    "description": ""
  },
  "DirectionLookup.Up": {
    "prefix": "Soko.DIRECTION.Up",
    "body": "Soko.DIRECTION.Up",
    "description": ""
  },
  "Soko.aspectRatio": {
    "prefix": "Soko:aspectRatio",
    "body": "Soko:aspectRatio()",
    "description": ""
  },
  "Soko.cleanNoise": {
    "prefix": "Soko:cleanNoise",
    "body": "Soko:cleanNoise()",
    "description": ""
  },
  "Soko.color": {
    "prefix": "Soko:color",
    "body": "Soko:color(r, g, b, a)",
    "description": ""
  },
  "Soko.dirtyNoise": {
    "prefix": "Soko:dirtyNoise",
    "body": "Soko:dirtyNoise()",
    "description": ""
  },
  "Soko.frameSize": {
    "prefix": "Soko:frameSize",
    "body": "Soko:frameSize(sheetName, frame)",
    "description": ""
  },
  "Soko.gridPosition": {
    "prefix": "Soko:gridPosition",
    "body": "Soko:gridPosition(x, y)",
    "description": ""
  },
  "Soko.gridRoomSize": {
    "prefix": "Soko:gridRoomSize",
    "body": "Soko:gridRoomSize()",
    "description": "The size of an automatically generated \"grid room\""
  },
  "Soko.halfTileSize": {
    "prefix": "Soko:halfTileSize",
    "body": "Soko:halfTileSize()",
    "description": ""
  },
  "Soko.keysFromTable": {
    "prefix": "Soko:keysFromTable",
    "body": "Soko:keysFromTable(table)",
    "description": ""
  },
  "Soko.list": {
    "prefix": "Soko:list",
    "body": "Soko:list()",
    "description": ""
  },
  "Soko.noise": {
    "prefix": "Soko:noise",
    "body": "Soko:noise(seed)",
    "description": ""
  },
  "Soko.parseColor": {
    "prefix": "Soko:parseColor",
    "body": "Soko:parseColor(rgbaString)",
    "description": ""
  },
  "Soko.parseGridPosition": {
    "prefix": "Soko:parseGridPosition",
    "body": "Soko:parseGridPosition(gridPositionString)",
    "description": ""
  },
  "Soko.pixelPosition": {
    "prefix": "Soko:pixelPosition",
    "body": "Soko:pixelPosition(x, y)",
    "description": ""
  },
  "Soko.rectangle": {
    "prefix": "Soko:rectangle",
    "body": "Soko:rectangle(x, y, width, height)",
    "description": ""
  },
  "Soko.rectangleFromPoint": {
    "prefix": "Soko:rectangleFromPoint",
    "body": "Soko:rectangleFromPoint(pixelPosition, width, height)",
    "description": ""
  },
  "Soko.stringToList": {
    "prefix": "Soko:stringToList",
    "body": "Soko:stringToList(str)",
    "description": "Converts a string of the format \"[x, y, z]\" to a LuaList of the format {x, y, z}"
  },
  "Soko.toGridPosition": {
    "prefix": "Soko:toGridPosition",
    "body": "Soko:toGridPosition(pixelPosition)",
    "description": ""
  },
  "Soko.toPixelPosition": {
    "prefix": "Soko:toPixelPosition",
    "body": "Soko:toPixelPosition(gridPosition)",
    "description": ""
  },
  "Soko.topLayerIndex": {
    "prefix": "Soko:topLayerIndex",
    "body": "Soko:topLayerIndex()",
    "description": ""
  },
  "Soko.tweenable": {
    "prefix": "Soko:tweenable",
    "body": "Soko:tweenable(getter, setter, lerp)",
    "description": "Creates a tweenable object."
  },
  "Soko.Direction": {
    "prefix": "Soko.Direction",
    "body": "Soko.Direction",
    "description": ""
  },
  "Soko.Input": {
    "prefix": "Soko.Input",
    "body": "Soko.Input",
    "description": ""
  },
  "AnimatedObject.destroy": {
    "prefix": "animatedObject:destroy",
    "body": "animatedObject:destroy()",
    "description": ""
  },
  "AnimatedObject.isDestroyed": {
    "prefix": "animatedObject:isDestroyed",
    "body": "animatedObject:isDestroyed()",
    "description": ""
  },
  "AnimatedObject.setVisible": {
    "prefix": "animatedObject:setVisible",
    "body": "animatedObject:setVisible(visible)",
    "description": ""
  },
  "AnimatedObject.state": {
    "prefix": "animatedObject.state",
    "body": "animatedObject.state",
    "description": ""
  },
  "AnimatedObject.tweenableAngle": {
    "prefix": "animatedObject.tweenableAngle",
    "body": "animatedObject.tweenableAngle",
    "description": ""
  },
  "AnimatedObject.tweenableOpacity": {
    "prefix": "animatedObject.tweenableOpacity",
    "body": "animatedObject.tweenableOpacity",
    "description": ""
  },
  "AnimatedObject.tweenablePosition": {
    "prefix": "animatedObject.tweenablePosition",
    "body": "animatedObject.tweenablePosition",
    "description": ""
  },
  "AnimatedObject.tweenableScale": {
    "prefix": "animatedObject.tweenableScale",
    "body": "animatedObject.tweenableScale",
    "description": ""
  },
  "Camera.clearOffset": {
    "prefix": "World.camera:clearOffset",
    "body": "World.camera:clearOffset(duration)",
    "description": ""
  },
  "Camera.hideVignette": {
    "prefix": "World.camera:hideVignette",
    "body": "World.camera:hideVignette()",
    "description": ""
  },
  "Camera.isAnimating": {
    "prefix": "World.camera:isAnimating",
    "body": "World.camera:isAnimating()",
    "description": ""
  },
  "Camera.setOffset": {
    "prefix": "World.camera:setOffset",
    "body": "World.camera:setOffset(pixelPosition, duration)",
    "description": ""
  },
  "Camera.setVignette": {
    "prefix": "World.camera:setVignette",
    "body": "World.camera:setVignette(outer, inner, color)",
    "description": "Sets up the camera vignette."
  },
  "Camera.showVignette": {
    "prefix": "World.camera:showVignette",
    "body": "World.camera:showVignette()",
    "description": ""
  },
  "Camera.tweenableViewBounds": {
    "prefix": "World.camera:tweenableViewBounds",
    "body": "World.camera:tweenableViewBounds()",
    "description": ""
  },
  "Camera.tweenableVignettePercent": {
    "prefix": "World.camera:tweenableVignettePercent",
    "body": "World.camera:tweenableVignettePercent()",
    "description": ""
  },
  "Color.clone": {
    "prefix": "color:clone",
    "body": "color:clone()",
    "description": ""
  },
  "Color.hex": {
    "prefix": "color:hex",
    "body": "color:hex()",
    "description": ""
  },
  "Color.withAlpha": {
    "prefix": "color:withAlpha",
    "body": "color:withAlpha(alpha)",
    "description": ""
  },
  "Color.alpha": {
    "prefix": "color.alpha",
    "body": "color.alpha",
    "description": ""
  },
  "Color.blue": {
    "prefix": "color.blue",
    "body": "color.blue",
    "description": ""
  },
  "Color.green": {
    "prefix": "color.green",
    "body": "color.green",
    "description": ""
  },
  "Color.red": {
    "prefix": "color.red",
    "body": "color.red",
    "description": ""
  },
  "Direction.next": {
    "prefix": "direction:next",
    "body": "direction:next()",
    "description": ""
  },
  "Direction.previous": {
    "prefix": "direction:previous",
    "body": "direction:previous()",
    "description": ""
  },
  "Direction.toAngle": {
    "prefix": "direction:toAngle",
    "body": "direction:toAngle()",
    "description": ""
  },
  "Direction.toGridPosition": {
    "prefix": "direction:toGridPosition",
    "body": "direction:toGridPosition()",
    "description": ""
  },
  "Direction.toPixelPosition": {
    "prefix": "direction:toPixelPosition",
    "body": "direction:toPixelPosition()",
    "description": ""
  },
  "Direction.name": {
    "prefix": "direction.name",
    "body": "direction.name",
    "description": ""
  },
  "DrawArguments.elapsedTime": {
    "prefix": "drawArguments:elapsedTime",
    "body": "drawArguments:elapsedTime()",
    "description": ""
  },
  "DrawArguments.isEditor": {
    "prefix": "drawArguments:isEditor",
    "body": "drawArguments:isEditor()",
    "description": "True if the renderer is running inside SokoMaker Editor"
  },
  "DrawArguments.screenRectangle": {
    "prefix": "drawArguments:screenRectangle",
    "body": "drawArguments:screenRectangle()",
    "description": "Rectangle representing the whole screen"
  },
  "DrawArguments.worldRectangle": {
    "prefix": "drawArguments:worldRectangle",
    "body": "drawArguments:worldRectangle()",
    "description": "Drawable Rectangle of the object being drawn"
  },
  "DrawArguments.gridPosition": {
    "prefix": "drawArguments.gridPosition",
    "body": "drawArguments.gridPosition",
    "description": "Grid Position of the object being drawn"
  },
  "DrawArguments.state": {
    "prefix": "drawArguments.state",
    "body": "drawArguments.state",
    "description": "State of the object being drawn"
  },
  "DrawArguments.worldPosition": {
    "prefix": "drawArguments.worldPosition",
    "body": "drawArguments.worldPosition",
    "description": "World position of the object being drawn"
  },
  "Entity.asEntity": {
    "prefix": "entity:asEntity",
    "body": "entity:asEntity()",
    "description": ""
  },
  "Entity.asTile": {
    "prefix": "entity:asTile",
    "body": "entity:asTile()",
    "description": ""
  },
  "Entity.centerWorldPosition": {
    "prefix": "entity:centerWorldPosition",
    "body": "entity:centerWorldPosition()",
    "description": ""
  },
  "Entity.checkTrait": {
    "prefix": "entity:checkTrait",
    "body": "entity:checkTrait(traitName, valueName)",
    "description": ""
  },
  "Entity.destroy": {
    "prefix": "entity:destroy",
    "body": "entity:destroy()",
    "description": ""
  },
  "Entity.isDestroyed": {
    "prefix": "entity:isDestroyed",
    "body": "entity:isDestroyed()",
    "description": ""
  },
  "Entity.isEntity": {
    "prefix": "entity:isEntity",
    "body": "entity:isEntity()",
    "description": ""
  },
  "Entity.isTile": {
    "prefix": "entity:isTile",
    "body": "entity:isTile()",
    "description": ""
  },
  "Entity.makeDirectionalMove": {
    "prefix": "entity:makeDirectionalMove",
    "body": "entity:makeDirectionalMove(direction)",
    "description": "Generates (but does not execute) a Move object."
  },
  "Entity.makeMove": {
    "prefix": "entity:makeMove",
    "body": "entity:makeMove(position)",
    "description": "Generates (but does not execute) a Move object."
  },
  "Entity.raise": {
    "prefix": "entity:raise",
    "body": "entity:raise(eventName, argsTable)",
    "description": ""
  },
  "Entity.setTraitByName": {
    "prefix": "entity:setTraitByName",
    "body": "entity:setTraitByName(traitName, desiredValueName)",
    "description": ""
  },
  "Entity.setVisible": {
    "prefix": "entity:setVisible",
    "body": "entity:setVisible(visible)",
    "description": ""
  },
  "Entity.templateName": {
    "prefix": "entity:templateName",
    "body": "entity:templateName()",
    "description": ""
  },
  "Entity.traitValue": {
    "prefix": "entity:traitValue",
    "body": "entity:traitValue(traitName)",
    "description": ""
  },
  "Entity.direction": {
    "prefix": "entity.direction",
    "body": "entity.direction",
    "description": ""
  },
  "Entity.gridPosition": {
    "prefix": "entity.gridPosition",
    "body": "entity.gridPosition",
    "description": ""
  },
  "Entity.state": {
    "prefix": "entity.state",
    "body": "entity.state",
    "description": "Blob of arbitrary data. Certain special keys affect rendering."
  },
  "Entity.tweenableOffset": {
    "prefix": "entity.tweenableOffset",
    "body": "entity.tweenableOffset",
    "description": ""
  },
  "Gridling.asEntity": {
    "prefix": "gridling:asEntity",
    "body": "gridling:asEntity()",
    "description": ""
  },
  "Gridling.asTile": {
    "prefix": "gridling:asTile",
    "body": "gridling:asTile()",
    "description": ""
  },
  "Gridling.centerWorldPosition": {
    "prefix": "gridling:centerWorldPosition",
    "body": "gridling:centerWorldPosition()",
    "description": ""
  },
  "Gridling.checkTrait": {
    "prefix": "gridling:checkTrait",
    "body": "gridling:checkTrait(traitName, valueName)",
    "description": ""
  },
  "Gridling.isEntity": {
    "prefix": "gridling:isEntity",
    "body": "gridling:isEntity()",
    "description": ""
  },
  "Gridling.isTile": {
    "prefix": "gridling:isTile",
    "body": "gridling:isTile()",
    "description": ""
  },
  "Gridling.raise": {
    "prefix": "gridling:raise",
    "body": "gridling:raise(eventName, argsTable)",
    "description": ""
  },
  "Gridling.templateName": {
    "prefix": "gridling:templateName",
    "body": "gridling:templateName()",
    "description": ""
  },
  "Gridling.traitValue": {
    "prefix": "gridling:traitValue",
    "body": "gridling:traitValue(traitName)",
    "description": ""
  },
  "Gridling.gridPosition": {
    "prefix": "gridling.gridPosition",
    "body": "gridling.gridPosition",
    "description": ""
  },
  "Gridling.state": {
    "prefix": "gridling.state",
    "body": "gridling.state",
    "description": "Blob of arbitrary data. Certain special keys affect rendering."
  },
  "GridPosition.absolute": {
    "prefix": "gridPosition:absolute",
    "body": "gridPosition:absolute()",
    "description": ""
  },
  "GridPosition.addDirection": {
    "prefix": "gridPosition:addDirection",
    "body": "gridPosition:addDirection(direction)",
    "description": ""
  },
  "GridPosition.clone": {
    "prefix": "gridPosition:clone",
    "body": "gridPosition:clone()",
    "description": ""
  },
  "GridPosition.maxXY": {
    "prefix": "gridPosition:maxXY",
    "body": "gridPosition:maxXY()",
    "description": ""
  },
  "GridPosition.subtractDirection": {
    "prefix": "gridPosition:subtractDirection",
    "body": "gridPosition:subtractDirection(direction)",
    "description": ""
  },
  "GridPosition.x": {
    "prefix": "gridPosition.x",
    "body": "gridPosition.x",
    "description": ""
  },
  "GridPosition.y": {
    "prefix": "gridPosition.y",
    "body": "gridPosition.y",
    "description": ""
  },
  "Input.direction": {
    "prefix": "input.direction",
    "body": "input.direction",
    "description": ""
  },
  "Input.isPrimary": {
    "prefix": "input.isPrimary",
    "body": "input.isPrimary",
    "description": ""
  },
  "Input.isReset": {
    "prefix": "input.isReset",
    "body": "input.isReset",
    "description": ""
  },
  "Input.isSecondary": {
    "prefix": "input.isSecondary",
    "body": "input.isSecondary",
    "description": ""
  },
  "List.add": {
    "prefix": "list:add",
    "body": "list:add(obj)",
    "description": ""
  },
  "List.clear": {
    "prefix": "list:clear",
    "body": "list:clear()",
    "description": ""
  },
  "List.size": {
    "prefix": "list:size",
    "body": "list:size()",
    "description": "Returns the value of the highest index"
  },
  "List.sort": {
    "prefix": "list:sort",
    "body": "list:sort(comparison)",
    "description": "Sorts the contents of the list using a provided comparison function.\r\n                The comparison function must take 2 parameters: 2 elements of the list (a, b).\r\n                The comparison function must then return an integral number, negative means \"a is smaller than b,\" positive means\r\n                \"a is bigger than b\" and 0 means they're equivalent. If the comparison function returns a decimal number, it will be truncated."
  },
  "Move.cancel": {
    "prefix": "move:cancel",
    "body": "move:cancel()",
    "description": ""
  },
  "Move.execute": {
    "prefix": "move:execute",
    "body": "move:execute()",
    "description": ""
  },
  "Move.movingEntity": {
    "prefix": "move:movingEntity",
    "body": "move:movingEntity()",
    "description": ""
  },
  "Move.startPosition": {
    "prefix": "move:startPosition",
    "body": "move:startPosition()",
    "description": ""
  },
  "Move.stop": {
    "prefix": "move:stop",
    "body": "move:stop()",
    "description": ""
  },
  "Move.targetPosition": {
    "prefix": "move:targetPosition",
    "body": "move:targetPosition()",
    "description": ""
  },
  "Move.wasAllowed": {
    "prefix": "move:wasAllowed",
    "body": "move:wasAllowed()",
    "description": ""
  },
  "Move.wasCancelled": {
    "prefix": "move:wasCancelled",
    "body": "move:wasCancelled()",
    "description": ""
  },
  "Move.direction": {
    "prefix": "move.direction",
    "body": "move.direction",
    "description": ""
  },
  "Painter.drawCircle": {
    "prefix": "painter:drawCircle",
    "body": "painter:drawCircle(center, radius, thickness, segments)",
    "description": ""
  },
  "Painter.drawFillRectangle": {
    "prefix": "painter:drawFillRectangle",
    "body": "painter:drawFillRectangle(rectangle)",
    "description": ""
  },
  "Painter.drawFirstFrame": {
    "prefix": "painter:drawFirstFrame",
    "body": "painter:drawFirstFrame(sheetName, position, angle)",
    "description": ""
  },
  "Painter.drawFrame": {
    "prefix": "painter:drawFrame",
    "body": "painter:drawFrame(sheetName, frame, position, angle, scale)",
    "description": ""
  },
  "Painter.drawLine": {
    "prefix": "painter:drawLine",
    "body": "painter:drawLine(start, end, thickness)",
    "description": ""
  },
  "Painter.drawProp": {
    "prefix": "painter:drawProp",
    "body": "painter:drawProp(sheetName, position, angle)",
    "description": ""
  },
  "Painter.drawText": {
    "prefix": "painter:drawText",
    "body": "painter:drawText(text, position, restrictWidth, angle, centered)",
    "description": ""
  },
  "Painter.measureText": {
    "prefix": "painter:measureText",
    "body": "painter:measureText(text, restrictWidth)",
    "description": "Obtains a rectangle representing the size of a string at the current font size. One day this might get moved int a \"Font\" class."
  },
  "Painter.setColor": {
    "prefix": "painter:setColor",
    "body": "painter:setColor(rgbaHexColor)",
    "description": ""
  },
  "Painter.setFontSize": {
    "prefix": "painter:setFontSize",
    "body": "painter:setFontSize(size)",
    "description": ""
  },
  "PixelPosition.absolute": {
    "prefix": "position:absolute",
    "body": "position:absolute()",
    "description": ""
  },
  "PixelPosition.axis": {
    "prefix": "position:axis",
    "body": "position:axis(luaDirection)",
    "description": ""
  },
  "PixelPosition.clone": {
    "prefix": "position:clone",
    "body": "position:clone()",
    "description": ""
  },
  "PixelPosition.maxXY": {
    "prefix": "position:maxXY",
    "body": "position:maxXY()",
    "description": ""
  },
  "PixelPosition.x": {
    "prefix": "position.x",
    "body": "position.x",
    "description": ""
  },
  "PixelPosition.y": {
    "prefix": "position.y",
    "body": "position.y",
    "description": ""
  },
  "ReadableState.get": {
    "prefix": "readonlyState:get",
    "body": "readonlyState:get(key)",
    "description": "Gets the key within the table. Returns nil if it's not found.\r\n                You can also use the [] syntax similar to a table."
  },
  "ReadableState.has": {
    "prefix": "readonlyState:has",
    "body": "readonlyState:has(key)",
    "description": "Returns true if the key exists in the table"
  },
  "ReadableState.keys": {
    "prefix": "readonlyState:keys",
    "body": "readonlyState:keys()",
    "description": ""
  },
  "Rectangle.bottomLeft": {
    "prefix": "rectangle:bottomLeft",
    "body": "rectangle:bottomLeft()",
    "description": ""
  },
  "Rectangle.bottomRight": {
    "prefix": "rectangle:bottomRight",
    "body": "rectangle:bottomRight()",
    "description": ""
  },
  "Rectangle.center": {
    "prefix": "rectangle:center",
    "body": "rectangle:center()",
    "description": ""
  },
  "Rectangle.constrain": {
    "prefix": "rectangle:constrain",
    "body": "rectangle:constrain(constrainingRectangle)",
    "description": ""
  },
  "Rectangle.envelopes": {
    "prefix": "rectangle:envelopes",
    "body": "rectangle:envelopes(rectToEnvelope)",
    "description": ""
  },
  "Rectangle.inflated": {
    "prefix": "rectangle:inflated",
    "body": "rectangle:inflated(size)",
    "description": ""
  },
  "Rectangle.size": {
    "prefix": "rectangle:size",
    "body": "rectangle:size()",
    "description": ""
  },
  "Rectangle.topLeft": {
    "prefix": "rectangle:topLeft",
    "body": "rectangle:topLeft()",
    "description": ""
  },
  "Rectangle.topRight": {
    "prefix": "rectangle:topRight",
    "body": "rectangle:topRight()",
    "description": ""
  },
  "Rectangle.zoomedIn": {
    "prefix": "rectangle:zoomedIn",
    "body": "rectangle:zoomedIn(zoomAmount, focalPoint)",
    "description": ""
  },
  "Rectangle.zoomedOut": {
    "prefix": "rectangle:zoomedOut",
    "body": "rectangle:zoomedOut(zoomAmount, focalPoint)",
    "description": ""
  },
  "Rectangle.height": {
    "prefix": "rectangle.height",
    "body": "rectangle.height",
    "description": ""
  },
  "Rectangle.width": {
    "prefix": "rectangle.width",
    "body": "rectangle.width",
    "description": ""
  },
  "Rectangle.x": {
    "prefix": "rectangle.x",
    "body": "rectangle.x",
    "description": ""
  },
  "Rectangle.y": {
    "prefix": "rectangle.y",
    "body": "rectangle.y",
    "description": ""
  },
  "Room.allEntities": {
    "prefix": "room:allEntities",
    "body": "room:allEntities()",
    "description": "Returns a list of all entities in this room."
  },
  "Room.allGridlings": {
    "prefix": "room:allGridlings",
    "body": "room:allGridlings()",
    "description": "Returns a list of all entities in this room."
  },
  "Room.allTiles": {
    "prefix": "room:allTiles",
    "body": "room:allTiles()",
    "description": "Returns a list of all tiles in this room, cached at the moment this function was called."
  },
  "Room.bottomRight": {
    "prefix": "room:bottomRight",
    "body": "room:bottomRight()",
    "description": ""
  },
  "Room.containsGridPosition": {
    "prefix": "room:containsGridPosition",
    "body": "room:containsGridPosition(luaGridPosition)",
    "description": ""
  },
  "Room.raiseEntityEvent": {
    "prefix": "room:raiseEntityEvent",
    "body": "room:raiseEntityEvent(eventName, parameters)",
    "description": "Raises and event for all entities in this room. This calls a function on the Behavior of each entity."
  },
  "Room.raiseEvent": {
    "prefix": "room:raiseEvent",
    "body": "room:raiseEvent(eventName, parameters)",
    "description": "Raises and event for all gridlings in this room. This calls a function on the Behavior of each gridling."
  },
  "Room.topLeft": {
    "prefix": "room:topLeft",
    "body": "room:topLeft()",
    "description": ""
  },
  "Room.usableSpacePixels": {
    "prefix": "room:usableSpacePixels",
    "body": "room:usableSpacePixels()",
    "description": ""
  },
  "Room.viewBounds": {
    "prefix": "room:viewBounds",
    "body": "room:viewBounds()",
    "description": ""
  },
  "Room.state": {
    "prefix": "room.state",
    "body": "room.state",
    "description": ""
  },
  "Size.toPixelPosition": {
    "prefix": "size:toPixelPosition",
    "body": "size:toPixelPosition()",
    "description": ""
  },
  "Size.height": {
    "prefix": "size.height",
    "body": "size.height",
    "description": ""
  },
  "Size.width": {
    "prefix": "size.width",
    "body": "size.width",
    "description": ""
  },
  "SoundDescriptor.stop": {
    "prefix": "sound:stop",
    "body": "sound:stop()",
    "description": ""
  },
  "SoundDescriptor.tweenableVolume": {
    "prefix": "sound.tweenableVolume",
    "body": "sound.tweenableVolume",
    "description": ""
  },
  "Tween.callback": {
    "prefix": "tween:callback",
    "body": "tween:callback(luaFunction)",
    "description": ""
  },
  "Tween.dynamic": {
    "prefix": "tween:dynamic",
    "body": "tween:dynamic(luaFunction)",
    "description": ""
  },
  "Tween.endMultiplex": {
    "prefix": "tween:endMultiplex",
    "body": "tween:endMultiplex()",
    "description": ""
  },
  "Tween.endSequence": {
    "prefix": "tween:endSequence",
    "body": "tween:endSequence()",
    "description": ""
  },
  "Tween.interpolate": {
    "prefix": "tween:interpolate",
    "body": "tween:interpolate(tweenSpecification, duration, easeFunctionName)",
    "description": ""
  },
  "Tween.startLoopSequence": {
    "prefix": "tween:startLoopSequence",
    "body": "tween:startLoopSequence()",
    "description": ""
  },
  "Tween.startMultiplex": {
    "prefix": "tween:startMultiplex",
    "body": "tween:startMultiplex()",
    "description": ""
  },
  "Tween.startSequence": {
    "prefix": "tween:startSequence",
    "body": "tween:startSequence()",
    "description": ""
  },
  "Tween.wait": {
    "prefix": "tween:wait",
    "body": "tween:wait(seconds)",
    "description": ""
  },
  "Tween.waitUntil": {
    "prefix": "tween:waitUntil",
    "body": "tween:waitUntil(waitUntilCallback)",
    "description": ""
  },
  "World.allEntities": {
    "prefix": "World:allEntities",
    "body": "World:allEntities()",
    "description": "Returns a List of all entities in the level."
  },
  "World.checkDialogueExists": {
    "prefix": "World:checkDialogueExists",
    "body": "World:checkDialogueExists(sceneName)",
    "description": "Returns true if the dialogue scene exists."
  },
  "World.colorKeys": {
    "prefix": "World:colorKeys",
    "body": "World:colorKeys()",
    "description": ""
  },
  "World.entitiesAt": {
    "prefix": "World:entitiesAt",
    "body": "World:entitiesAt(gridPosition)",
    "description": ""
  },
  "World.finishChapter": {
    "prefix": "World:finishChapter",
    "body": "World:finishChapter()",
    "description": ""
  },
  "World.gridlingsAt": {
    "prefix": "World:gridlingsAt",
    "body": "World:gridlingsAt(gridPosition)",
    "description": ""
  },
  "World.isShowingDialogue": {
    "prefix": "World:isShowingDialogue",
    "body": "World:isShowingDialogue()",
    "description": "Returns true if the Dialogue Box is open."
  },
  "World.loadLevel": {
    "prefix": "World:loadLevel",
    "body": "World:loadLevel(levelName, overrideTable)",
    "description": "Loads the desired level at the end of the frame."
  },
  "World.loopSound": {
    "prefix": "World:loopSound",
    "body": "World:loopSound(soundName, volume, pitch, pan)",
    "description": ""
  },
  "World.playAnimation": {
    "prefix": "World:playAnimation",
    "body": "World:playAnimation(animationFunction, parametersTable)",
    "description": "Plays an animation DURING THE TURN, the turn will not be over until the animation is complete"
  },
  "World.playAsyncAnimation": {
    "prefix": "World:playAsyncAnimation",
    "body": "World:playAsyncAnimation(animationFunction, parametersTable)",
    "description": "Plays an animation outside the turn, animation will run until it is over or until you leave the room"
  },
  "World.playSong": {
    "prefix": "World:playSong",
    "body": "World:playSong(trackName, loop)",
    "description": ""
  },
  "World.playSound": {
    "prefix": "World:playSound",
    "body": "World:playSound(soundName, volume, pitch, pan)",
    "description": ""
  },
  "World.raiseEntityEvent": {
    "prefix": "World:raiseEntityEvent",
    "body": "World:raiseEntityEvent(eventName, parameters)",
    "description": "Raises and event for all entities in the level. This calls a function on the Behavior of each entity. This can be quite slow!"
  },
  "World.raiseEvent": {
    "prefix": "World:raiseEvent",
    "body": "World:raiseEvent(eventName, parameters)",
    "description": "Runs an event on all gridlings at the specified location"
  },
  "World.raiseEventAt": {
    "prefix": "World:raiseEventAt",
    "body": "World:raiseEventAt(gridPosition, eventName, parameters)",
    "description": "Runs an event on all gridlings at the specified location"
  },
  "World.rebuildLevel": {
    "prefix": "World:rebuildLevel",
    "body": "World:rebuildLevel()",
    "description": "Rebuilds the current level without affecting the state"
  },
  "World.reset": {
    "prefix": "World:reset",
    "body": "World:reset()",
    "description": "Resets the current level, clearing its state."
  },
  "World.roomAt": {
    "prefix": "World:roomAt",
    "body": "World:roomAt(gridPosition)",
    "description": ""
  },
  "World.setTileAt": {
    "prefix": "World:setTileAt",
    "body": "World:setTileAt(gridPosition, tileTemplateName)",
    "description": ""
  },
  "World.showBespokeDialogue": {
    "prefix": "World:showBespokeDialogue",
    "body": "World:showBespokeDialogue(settings)",
    "description": "Shows the Dialogue Box with custom data."
  },
  "World.showSceneDialogue": {
    "prefix": "World:showSceneDialogue",
    "body": "World:showSceneDialogue(sceneName)",
    "description": "Shows Dialog Box and runs a scene. If the scene is not found this will display an error message in the Dialogue\r\n                Box."
  },
  "World.spawnEntity": {
    "prefix": "World:spawnEntity",
    "body": "World:spawnEntity(gridPosition, entityTemplateName, direction)",
    "description": ""
  },
  "World.spawnObject": {
    "prefix": "World:spawnObject",
    "body": "World:spawnObject(gridPosition)",
    "description": "Spawn an animated object that can be controlled and tweened."
  },
  "World.stopSong": {
    "prefix": "World:stopSong",
    "body": "World:stopSong()",
    "description": ""
  },
  "World.tileAt": {
    "prefix": "World:tileAt",
    "body": "World:tileAt(gridPosition)",
    "description": ""
  },
  "World.whenTurnIsOver": {
    "prefix": "World:whenTurnIsOver",
    "body": "World:whenTurnIsOver(luaFunction)",
    "description": ""
  },
  "World.camera": {
    "prefix": "World.camera",
    "body": "World.camera",
    "description": "The game camera"
  },
  "World.levelState": {
    "prefix": "World.levelState",
    "body": "World.levelState",
    "description": "Data that will be reset when a new level is loaded"
  },
  "World.state": {
    "prefix": "World.state",
    "body": "World.state",
    "description": "Data that stays persistent through the whole \"run\" (even across levels)"
  },
  "WritableState.addOtherState": {
    "prefix": "state:addOtherState",
    "body": "state:addOtherState(state)",
    "description": "Copies another objects State into this object. Any matching keys will be overwritten."
  },
  "WritableState.addTable": {
    "prefix": "state:addTable",
    "body": "state:addTable(table)",
    "description": "Copies a table into the state. Any key defined in the table will be used to define in the State."
  },
  "WritableState.clear": {
    "prefix": "state:clear",
    "body": "state:clear(key)",
    "description": "Deletes entry in the table."
  },
  "WritableState.get": {
    "prefix": "state:get",
    "body": "state:get(key)",
    "description": "Gets the key within the table. Returns nil if it's not found.\r\n                You can also use the [] syntax similar to a table."
  },
  "WritableState.has": {
    "prefix": "state:has",
    "body": "state:has(key)",
    "description": "Returns true if the key exists in the table"
  },
  "WritableState.keys": {
    "prefix": "state:keys",
    "body": "state:keys()",
    "description": ""
  },
  "WritableState.set": {
    "prefix": "state:set",
    "body": "state:set(key, value)",
    "description": "Sets an entry within the table. You can also use the [] syntax."
  }
}
